// lib/features/product/product_edit_screen.dart
import 'dart:io';
import 'dart:convert';
import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb, debugPrint, kDebugMode;
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:go_router/go_router.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../models/post.dart';
import '../../api_service.dart';
import 'package:http/http.dart' as http;
import 'package:http_parser/http_parser.dart';
import 'package:jwt_decode/jwt_decode.dart';
import 'package:kumeong_store/utils/storage.dart';
import 'package:kumeong_store/core/theme.dart';

const String baseUrl = 'http://localhost:3000/api/v1';

class ProductEditScreen extends StatefulWidget {
  const ProductEditScreen(
      {super.key, required this.productId, this.initialProduct});
  final String productId;
  final Product? initialProduct;

  @override
  State<ProductEditScreen> createState() => _ProductEditScreenState();
}

class _ProductEditScreenState extends State<ProductEditScreen> {
  static const int _maxTags = 8;
  static const int _maxImages = 10;
  String? _userId;
  String? _token;

  final _titleCtrl = TextEditingController();
  final _priceCtrl = TextEditingController();
  final _descCtrl = TextEditingController();
  final _locationCtrl = TextEditingController();
  final _picker = ImagePicker();
  final List<dynamic> _images = [];
  final List<String> _tags = [];
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _loadUserId();
    final p = widget.initialProduct;
    if (p != null) {
      _titleCtrl.text = p.title?.toString() ?? '';
      _priceCtrl.text = p.price?.toString() ?? '';
      _descCtrl.text = p.description?.toString() ?? '';

      final categoryStr = p.category?.toString() ?? '';
      _tags.addAll(categoryStr.isEmpty ? [] : categoryStr.split(','));

      if (p.imageUrls.isNotEmpty) _images.addAll(p.imageUrls);

      _locationCtrl.text = p.location?.toString() ?? '';
    }
  }

  Future<void> _loadUserId() async {
    _token = await TokenStorage.getToken();
    if (_token != null && _token!.isNotEmpty) {
      final payload = Jwt.parseJwt(_token!);
      _userId = payload['sub']?.toString() ?? '';
      debugPrint('Loaded userId: $_userId');
    }
  }

  Future<void> _pickImage() async {
    if (_images.length >= _maxImages) return;
    final x = await _picker.pickImage(source: ImageSource.gallery);
    if (x != null) setState(() => _images.add(x));
  }

  Future<Map<String, dynamic>?> createProductWithImagesSafe(
    Map<String, dynamic> data,
    List<dynamic> images,
    String token, {
    bool isUpdate = false,
    String? productId,
  }) async {
    final uri = isUpdate
        ? Uri.parse('$baseUrl/products/$productId')
        : Uri.parse('$baseUrl/products');

    final request = http.MultipartRequest(isUpdate ? 'PUT' : 'POST', uri);
    request.headers['Authorization'] =
        'Bearer ${token.replaceAll('\n', '').trim()}';

    // -----------------------------
    // ÌïÑÏàò/ÏÑ†ÌÉù ÌïÑÎìú ÏïàÏ†Ñ Î≥ÄÌôò
    // -----------------------------
    final title = (data['title']?.toString().trim() ?? '');
    if (title.isEmpty || title.length > 100) {
      debugPrint('‚ùå title validation failed: "$title"');
      return null;
    }

    final priceWon = data['priceWon'] is int
        ? data['priceWon'] as int
        : int.tryParse(
                data['priceWon']?.toString().replaceAll(',', '') ?? '') ??
            -1;
    if (priceWon < 0) {
      debugPrint('‚ùå priceWon validation failed: $priceWon');
      return null;
    }

    final description = (data['description']?.toString().trim());
    final category = (data['category']?.toString().trim());
    final locationName = (data['location']?.toString().trim());

    // -----------------------------
// ÏÑúÎ≤Ñ Ï†ÑÏÜ° ÌïÑÎìú ÏÑ§Ï†ï
// -----------------------------
    request.fields['title'] = title;
    request.fields['priceWon'] = priceWon.toString();

// descriptionÏùÄ Ìï≠ÏÉÅ fieldsÎ°ú Ï†ÑÏÜ°
    if (data['description'] != null &&
        data['description'].toString().isNotEmpty) {
      request.fields['description'] = data['description']!.toString();
    }

    if (category != null && category.isNotEmpty)
      request.fields['category'] = category;
    if (locationName != null && locationName.isNotEmpty)
      request.fields['location'] = locationName;

    // -----------------------------
    // Ïù¥ÎØ∏ÏßÄ Ï≤®Î∂Ä
    // -----------------------------
    for (final image in images) {
      try {
        if (kIsWeb && image is XFile) {
          final bytes = await image.readAsBytes();
          request.files.add(http.MultipartFile.fromBytes(
            'images',
            bytes,
            filename: image.name,
            contentType: MediaType('image', 'jpeg'),
          ));
        } else if (!kIsWeb && image is File) {
          if (kIsWeb && image is XFile) {
            final bytes = await image.readAsBytes();
            request.files.add(http.MultipartFile.fromBytes(
              'images',
              bytes,
              filename: image.path.split('/').last,
              contentType: MediaType('image', 'jpeg'),
            ));
          } else if (!kIsWeb && image is File) {
            final stream = http.ByteStream(image.openRead());
            final length = await image.length();
            request.files.add(http.MultipartFile(
              'images',
              stream,
              length,
              filename: image.path.split('/').last,
              contentType: MediaType('image', 'jpeg'),
            ));
          }
        }
      } catch (e) {
        debugPrint('‚ùå Ïù¥ÎØ∏ÏßÄ Ï≤®Î∂Ä Ïã§Ìå®: $e');
      }
    }

    // -----------------------------
    // ÏöîÏ≤≠ Ï†ÑÏÜ°
    // -----------------------------
    try {
      final response = await request.send();
      final responseBody = await response.stream.bytesToString();

      if (response.statusCode == 201 || response.statusCode == 200) {
        debugPrint('‚úÖ ÏÉÅÌíà Îì±Î°ù/ÏàòÏ†ï ÏÑ±Í≥µ');
        final body = jsonDecode(responseBody);
        return (body['data'] ?? body) as Map<String, dynamic>;
      } else {
        debugPrint('‚ùå ÏÑúÎ≤Ñ validation Ïã§Ìå®: $responseBody');
        return null;
      }
    } catch (e, st) {
      debugPrint('üí• ÏÉÅÌíà Îì±Î°ù ÏòàÏô∏: $e\n$st');
      return null;
    }
  }

// -----------------------------
// _submitSafe() ÏµúÏ¢Ö ÏïàÏ†Ñ Î≤ÑÏ†Ñ
// -----------------------------
  Future<void> _submitSafe() async {
    final title = _titleCtrl.text.trim();
    final priceText = _priceCtrl.text.trim();

    if (title.isEmpty || priceText.isEmpty) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Ï†úÎ™©Í≥º Í∞ÄÍ≤©ÏùÑ Î∞òÎìúÏãú ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§.')));
      }
      return;
    }

    if (title.length > 100) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Ï†úÎ™©ÏùÄ 100Ïûê Ïù¥ÌïòÎ°ú ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§.')));
      }
      return;
    }

    final priceWon = int.tryParse(priceText.replaceAll(',', ''));
    if (priceWon == null || priceWon < 0) {
      if (context.mounted) {
        ScaffoldMessenger.of(context)
            .showSnackBar(const SnackBar(content: Text('Í∞ÄÍ≤©ÏùÄ 0 Ïù¥ÏÉÅÏùò Ï†ïÏàòÏó¨Ïïº Ìï©ÎãàÎã§.')));
      }
      return;
    }

    if (_userId == null || _token == null) await _loadUserId();
    if (_token == null || _token!.isEmpty) {
      if (context.mounted) {
        ScaffoldMessenger.of(context)
            .showSnackBar(const SnackBar(content: Text('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.')));
        context.go('/');
      }
      return;
    }

    setState(() => _isLoading = true);

    final productData = {
      'title': title,
      'priceWon': priceWon,
      if (_descCtrl.text.trim().isNotEmpty)
        'description': _descCtrl.text.trim(),
      if (_tags.isNotEmpty) 'category': _tags.join(','),
      if (_locationCtrl.text.trim().isNotEmpty)
        'location': _locationCtrl.text.trim(),
    };

    Map<String, dynamic>? result;
    if (widget.initialProduct == null) {
      result = await createProductWithImagesSafe(productData, _images, _token!);
    } else {
      result = await createProductWithImagesSafe(
        productData,
        _images,
        _token!,
        isUpdate: true,
        productId: widget.productId,
      );
    }

    if (result != null) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
            content:
                Text(widget.initialProduct == null ? 'ÏÉÅÌíà Îì±Î°ù ÏôÑÎ£å' : 'ÏÉÅÌíà ÏàòÏ†ï ÏôÑÎ£å')));
        final product = Product.fromJson(result);
        context.pop(product);
      }
    } else {
      if (mounted) {
        ScaffoldMessenger.of(context)
            .showSnackBar(const SnackBar(content: Text('ÏÉÅÌíà Îì±Î°ù/ÏàòÏ†ï Ïã§Ìå®')));
      }
    }

    if (mounted) setState(() => _isLoading = false);
  }

  @override
  void dispose() {
    _titleCtrl.dispose();
    _priceCtrl.dispose();
    _descCtrl.dispose();
    _locationCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final ext = Theme.of(context).extension<KuColors>()!;
    final isEditing = widget.initialProduct != null;

    return Scaffold(
      backgroundColor: cs.background,
      appBar: AppBar(
        backgroundColor: cs.primary,
        title: Text(isEditing ? 'ÏÉÅÌíà ÏàòÏ†ï' : 'ÏÉÅÌíà Îì±Î°ù',
            style: TextStyle(color: cs.onPrimary)),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => context.pop(),
        ),
      ),
      body: Stack(
        children: [
          SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 80),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildImagePicker(cs, ext),
                const SizedBox(height: 24),
                _buildLabel('Ï†úÎ™©', cs),
                const SizedBox(height: 4),
                _buildTextField(_titleCtrl, 'Ï†úÎ™© ÏûëÏÑ±', cs, ext),
                const SizedBox(height: 16),
                _buildLabel('Í∞ÄÍ≤©', cs),
                const SizedBox(height: 4),
                _buildTextField(_priceCtrl, 'Ïõê', cs, ext,
                    keyboardType: TextInputType.number),
                const SizedBox(height: 16),
                _buildLabel('ÏÉÅÏÑ∏ÏÑ§Î™Ö', cs),
                const SizedBox(height: 4),
                _buildTextField(_descCtrl, 'Ï†úÌíà ÏÑ§Î™Ö', cs, ext, maxLines: 6),
                const SizedBox(height: 16),
                _buildLabel('Í±∞Îûò ÏúÑÏπò', cs),
                const SizedBox(height: 4),
                _buildTextField(_locationCtrl, 'Ïòà: ÏÑúÏö∏ Í∞ïÎÇ®Íµ¨ Ïó≠ÏÇºÎèô', cs, ext),
                const SizedBox(height: 32),
                _buildLabel('ÌÉúÍ∑∏', cs),
                const SizedBox(height: 8),
                _buildTagSelector(cs, ext),
              ],
            ),
          ),
          if (_isLoading)
            Container(
              color: Colors.black26,
              child: const Center(child: CircularProgressIndicator()),
            ),
        ],
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
        child: FilledButton(
          onPressed: _submitSafe,
          style: FilledButton.styleFrom(
            backgroundColor: cs.primary,
            foregroundColor: cs.onPrimary,
            minimumSize: const Size.fromHeight(48),
          ),
          child:
              Text(isEditing ? 'ÏàòÏ†ïÌïòÍ∏∞' : 'Îì±Î°ùÌïòÍ∏∞', style: TextStyle(fontSize: 18)),
        ),
      ),
    );
  }

  Widget _buildLabel(String text, ColorScheme cs) => Text(text,
      style: TextStyle(fontWeight: FontWeight.w600, color: cs.onSurface));

  Widget _buildTextField(TextEditingController controller, String hintText,
      ColorScheme cs, KuColors ext,
      {int maxLines = 1, TextInputType? keyboardType}) {
    return TextField(
      controller: controller,
      maxLines: maxLines,
      keyboardType: keyboardType,
      decoration: InputDecoration(
        hintText: hintText,
        filled: true,
        fillColor: cs.surface,
        border: OutlineInputBorder(
            borderRadius: const BorderRadius.all(Radius.circular(8)),
            borderSide: BorderSide(color: ext.accentSoft)),
        enabledBorder: OutlineInputBorder(
            borderRadius: const BorderRadius.all(Radius.circular(8)),
            borderSide: BorderSide(color: ext.accentSoft)),
        focusedBorder: OutlineInputBorder(
            borderRadius: const BorderRadius.all(Radius.circular(8)),
            borderSide: BorderSide(color: cs.primary, width: 2)),
        isDense: true,
      ),
      style: TextStyle(color: cs.onSurface),
    );
  }

  Widget _buildImagePicker(ColorScheme cs, KuColors ext) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            ..._images.map((img) {
              return Stack(
                children: [
                  Container(
                    width: 100,
                    height: 100,
                    decoration: BoxDecoration(
                      color: cs.surface,
                      border: Border.all(color: ext.accentSoft),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: kIsWeb
                          ? (img is XFile
                              ? FutureBuilder<Uint8List>(
                                  future: img.readAsBytes(),
                                  builder: (context, snapshot) {
                                    if (snapshot.connectionState ==
                                        ConnectionState.done) {
                                      if (snapshot.hasError)
                                        return const Icon(Icons.error);
                                      return Image.memory(snapshot.data!,
                                          fit: BoxFit.cover);
                                    }
                                    return const Center(
                                        child: CircularProgressIndicator(
                                            strokeWidth: 2));
                                  },
                                )
                              : Image.network(img.toString(),
                                  fit: BoxFit.cover))
                          : Image.file(img as File, fit: BoxFit.cover),
                    ),
                  ),
                  Positioned(
                    right: 0,
                    top: 0,
                    child: GestureDetector(
                      onTap: () => setState(() => _images.remove(img)),
                      child: Container(
                        decoration: const BoxDecoration(
                            color: Colors.black54, shape: BoxShape.circle),
                        child: const Icon(Icons.close,
                            size: 20, color: Colors.white),
                      ),
                    ),
                  ),
                ],
              );
            }).toList(),
            if (_images.length < _maxImages)
              InkWell(
                onTap: _pickImage,
                borderRadius: BorderRadius.circular(8),
                child: Container(
                  width: 100,
                  height: 100,
                  decoration: BoxDecoration(
                      color: cs.surface,
                      border: Border.all(color: ext.accentSoft),
                      borderRadius: BorderRadius.circular(8)),
                  child: Icon(Icons.add, size: 36, color: cs.onSurfaceVariant),
                ),
              ),
          ],
        ),
        const SizedBox(height: 4),
        Text('${_images.length}/$_maxImages',
            style: TextStyle(fontSize: 12, color: cs.onSurface)),
      ],
    );
  }

  Widget _buildTagSelector(ColorScheme cs, KuColors ext) {
    return SizedBox(
      height: 40,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: [
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: cs.primary,
              foregroundColor: cs.onPrimary,
              padding: const EdgeInsets.symmetric(horizontal: 12),
              shape: const StadiumBorder(),
            ),
            onPressed: () async {
              if (_tags.length >= _maxTags) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('ÌÉúÍ∑∏Îäî ÏµúÎåÄ $_maxTagsÍ∞úÍπåÏßÄ ÏÑ†ÌÉùÌï† Ïàò ÏûàÏñ¥Ïöî.')),
                );
                return;
              }
              final tag = await showDialog<String>(
                  context: context, builder: (_) => const CategoryDialog());
              if (tag == null || _tags.contains(tag)) {
                if (_tags.contains(tag)) {
                  ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Ïù¥ÎØ∏ ÏÑ†ÌÉùÌïú ÌÉúÍ∑∏ÏòàÏöî.')));
                }
                return;
              }
              setState(() => _tags.add(tag));
            },
            child: const Text('ÌïÑÌÑ∞ +'),
          ),
          const SizedBox(width: 8),
          ..._tags.map(
            (t) => Padding(
              padding: const EdgeInsets.only(right: 4),
              child: Chip(
                label: Text(t),
                deleteIcon: const Icon(Icons.close),
                onDeleted: () => setState(() => _tags.remove(t)),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// CategoryDialog Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
class CategoryDialog extends StatelessWidget {
  const CategoryDialog({super.key});

  static const Map<String, List<String>> categories = {
    'ÎîîÏßÄÌÑ∏Í∏∞Í∏∞': ['Ïä§ÎßàÌä∏Ìè∞', 'ÌÉúÎ∏îÎ¶ø/ÎÖ∏Ìä∏Î∂Å', 'Îç∞Ïä§ÌÅ¨ÌÉë/Î™®ÎãàÌÑ∞', 'Ïπ¥Î©îÎùº/Ï¥¨ÏòÅÏû•ÎπÑ', 'Í≤åÏûÑÍ∏∞Í∏∞', 'Ïõ®Ïñ¥Îü¨Î∏î/Ï£ºÎ≥ÄÍ∏∞Í∏∞'],
    'Í∞ÄÏ†ÑÏ†úÌíà': ['TV/Î™®ÎãàÌÑ∞', 'ÎÉâÏû•Í≥†', 'ÏÑ∏ÌÉÅÍ∏∞/Ï≤≠ÏÜåÍ∏∞', 'ÏóêÏñ¥Ïª®/Í≥µÍ∏∞Ï≤≠Ï†ïÍ∏∞', 'Ï£ºÎ∞©Í∞ÄÏ†Ñ', 'Î∑∞Ìã∞Í∞ÄÏ†Ñ'],
    'ÏùòÎ•ò/Ìå®ÏÖò': ['ÎÇ®ÏÑ±ÏùòÎ•ò', 'Ïó¨ÏÑ±ÏùòÎ•ò', 'ÏïÑÎèôÏùòÎ•ò', 'Ïã†Î∞ú', 'Í∞ÄÎ∞©', 'Ïï°ÏÑ∏ÏÑúÎ¶¨'],
    'Í∞ÄÍµ¨/Ïù∏ÌÖåÎ¶¨Ïñ¥': ['Ïπ®ÎåÄ/Îß§Ìä∏Î¶¨Ïä§', 'Ï±ÖÏÉÅ/ÏùòÏûê', 'ÏÜåÌåå', 'ÏàòÎÇ©/ÌÖåÏù¥Î∏î', 'Ï°∞Î™Ö/Ïù∏ÌÖåÎ¶¨Ïñ¥ ÏÜåÌíà'],
    'ÏÉùÌôú/Ï£ºÎ∞©': ['Ï£ºÎ∞©Ïö©Ìíà', 'Ï≤≠ÏÜå/ÏÑ∏ÌÉÅÏö©Ìíà', 'ÏöïÏã§/ÏàòÎÇ©Ïö©Ìíà', 'ÏÉùÌôúÏû°Ìôî', 'Í∏∞ÌÉÄ ÏÉùÌôúÏÜåÌíà'],
    'Ïú†ÏïÑ/ÏïÑÎèô': ['Ïú†ÏïÑÏùòÎ•ò', 'Ïû•ÎÇúÍ∞ê/Ïú†Î™®Ï∞®/Ïπ¥ÏãúÌä∏', 'Ïú°ÏïÑÏö©Ìíà', 'Ïπ®Íµ¨/Í∞ÄÍµ¨'],
    'Ï∑®ÎØ∏/Í≤åÏûÑ/ÏùåÎ∞ò': ['Í≤åÏûÑ', 'Ïö¥ÎèôÏö©Ìíà', 'ÏùåÎ∞ò/LP', 'ÏïÖÍ∏∞', 'ÏïÑÏõÉÎèÑÏñ¥Ïö©Ìíà'],
    'ÎèÑÏÑú/Î¨∏Íµ¨': ['ÏÜåÏÑ§/ÏóêÏÑ∏Ïù¥', 'Ï∞∏Í≥†ÏÑú/Ï†ÑÍ≥µÏÑúÏ†Å', 'ÎßåÌôîÏ±Ö', 'Î¨∏Íµ¨/ÏÇ¨Î¨¥Ïö©Ìíà', 'Í∏∞ÌÉÄ ÎèÑÏÑúÎ•ò'],
    'Î∞òÎ†§ÎèôÎ¨º': ['ÏÇ¨Î£å/Í∞ÑÏãù', 'Ïû•ÎÇúÍ∞ê/Ïö©Ìíà', 'Ïù¥ÎèôÏû•/ÌïòÏö∞Ïä§', 'ÏùòÎ•ò/Î™©Ï§Ñ', 'Í∏∞ÌÉÄ Î∞òÎ†§Ïö©Ìíà'],
    'Í∏∞ÌÉÄ Ï§ëÍ≥†Î¨ºÌíà': ['Ìã∞Ïºì/ÏÉÅÌíàÍ∂å', 'ÌîºÍ∑úÏñ¥/ÌîÑÎùºÎ™®Îç∏', 'Í≥µÍµ¨/ÏûëÏóÖÎèÑÍµ¨', 'ÏàòÏßëÌíà', 'Í∏∞ÌÉÄ'],
  };

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return SimpleDialog(
      backgroundColor: cs.surface,
      title: Text('ÎåÄÎ∂ÑÎ•ò ÏÑ†ÌÉù', style: TextStyle(color: cs.onSurface)),
      children: categories.keys.map((mainCat) {
        return SimpleDialogOption(
          child: Text(mainCat, style: TextStyle(color: cs.onSurface)),
          onPressed: () async {
            final sub = await showDialog<String>(
              context: context,
              builder: (_) => SimpleDialog(
                backgroundColor: cs.surface,
                title: Text('$mainCat - ÏÜåÎ∂ÑÎ•ò ÏÑ†ÌÉù',
                    style: TextStyle(color: cs.onSurface)),
                children: categories[mainCat]!
                    .map((subCat) => SimpleDialogOption(
                          child: Text(subCat,
                              style: TextStyle(color: cs.onSurface)),
                          onPressed: () =>
                              Navigator.pop(context, '$mainCat > $subCat'),
                        ))
                    .toList(),
              ),
            );
            if (sub != null && context.mounted) Navigator.pop(context, sub);
          },
        );
      }).toList(),
    );
  }
}
